[PROCEDURE]
NAME LoadLexerProperties
PROTOTYPE '(csciControl sciControl, STRING lexer),LONG,PROC'
PARAMETERS '(csciControl sciControl, STRING lexer)'
[COMMON]
FROM ABC Source
MODIFIED '2014/03/04' '10:22:11'
[PROMPTS]
%GenerateOpenClose LONG  (0)
%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 50
PROPERTY:END
DOO CLASS                      !Created 05/24/20  1:32PM by Do2Class by Carl Barnes
ProcessFilePatterns PROCEDURE()
ProcessKeywords     PROCEDURE()
ProcessOptions      PROCEDURE()
ProcessStyles       PROCEDURE()
ProcessToken        PROCEDURE()
    END  !5 Routines Found


!region Notices
! ================================================================================
! Notice : Copyright (C) 2017, Devuna
!          Distributed under the MIT License (https://opensource.org/licenses/MIT)
!
!    This file is part of Devuna-KwikSourceSearch (https://github.com/Devuna/Devuna-KwikSourceSearch)
!
!    Devuna-KwikSourceSearch is free software: you can redistribute it and/or modify
!    it under the terms of the MIT License as published by
!    the Open Source Initiative.
!
!    Devuna-KwikSourceSearch is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    MIT License for more details.
!
!    You should have received a copy of the MIT License
!    along with Devuna-KwikSourceSearch.  If not, see <https://opensource.org/licenses/MIT>.
! ================================================================================
!endregion Notices
[SOURCE]
PROPERTY:BEGIN
PRIORITY 50
PROPERTY:END
returnCode           LONG(Level:Fatal)

szAAFileName         CSTRING(260),STATIC
A_A                  FILE,DRIVER('ASCII'),NAME(szAAFileName),PRE(AA)
Record                  RECORD
Buffer                     STRING(1024)
                        END
                     END
szBuffer             CSTRING(1025)

keywordQueue         QUEUE,PRE(kwq)
keywords                CSTRING(1025)
                     END
szKeywords           &CSTRING

styleNumber          LONG
thisToken            CSTRING(33)
[END]
EMBED %ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5000
PROPERTY:END
  szAAFilename = svSpecialFolder.GetDir(SV:CSIDL_APPDATA, 'Devuna' & '\' & 'KSS') & '\' & lexer & '.properties'
  OPEN(A_A,ReadOnly+DenyWrite)
  IF ERRORCODE()
     szAAFilename = lexer & '.properties'
     OPEN(A_A,ReadOnly+DenyWrite)
  END
  IF ~ERRORCODE()
     SET(A_A)
     NEXT(A_A)
     LOOP UNTIL ERRORCODE()
        szBuffer = CLIP(LEFT(A_A.Buffer))
        IF szBuffer <> '' AND szBuffer[1] = '['
           CASE UPPER(szBuffer[1 : 7])
             OF '[FILEPA'
                DOO.ProcessFilePatterns()
             OF '[OPTION'
                DOO.ProcessOptions()
             OF '[KEYWOR'
                DOO.ProcessKeywords()
             OF '[STYLES'
                DOO.ProcessStyles()
           ELSE
                NEXT(A_A)
           END
        ELSE
           NEXT(A_A)
        END
     END
     CLOSE(A_A)
     returnCode = Level:Benign
  ELSE
     MESSAGE('Unexpected error opening ' & szAAFilename & '|' & ERROR(),'Load Lexer Properties',ICON:HAND)
  END
  RETURN returnCode
[END]
EMBED %LocalProcedures
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
DOO.ProcessFilePatterns  PROCEDURE()
  CODE
   NEXT(A_A)
   LOOP UNTIL ERRORCODE()
        szBuffer = CLIP(LEFT(A_A.Buffer))
        IF szBuffer <> '' AND szBuffer[1] <> '!'
           IF szBuffer[1] = '['
              BREAK
           ELSE
              !pick out the file extensions for this lexer
           END
        END
        NEXT(A_A)
   END
   RETURN

DOO.ProcessOptions PROCEDURE()
szOption       CSTRING(256)
szOptionValue  CSTRING(256)
p              LONG
n              LONG

   CODE
      NEXT(A_A)
      LOOP UNTIL ERRORCODE()
           szBuffer = CLIP(LEFT(A_A.Buffer))
           IF szBuffer <> '' AND szBuffer[1] <> '!'
              IF szBuffer[1] = '['
                 BREAK
              ELSE
                 n = INSTRING(';',szBuffer)
                 IF n = 0
                    n = LEN(szBuffer)
                 ELSE
                    n -= 1
                 END
                 p = INSTRING('=',szBuffer)
                 IF p
                    !set properties for this lexer
                    szOption = LOWER(CLIP(szBuffer[1 : p-1]))
                    szOptionValue = szBuffer[p+1 : n]
                    CASE szOption
                    OF 'word.characters'
                       sciControl.SetWordChars(szOptionValue)
                    ELSE
                       sciControl.SetProperty(szOption,szOptionValue)
                    END
                 END
              END
           END
           NEXT(A_A)
      END
   RETURN

DOO.ProcessKeywords      PROCEDURE()
i              LONG
j              LONG
bytesNeeded    LONG
setNumber      LONG

   CODE
   !pick out set number
   setNumber = szBuffer[10 : LEN(szBuffer)-1]
   NEXT(A_A)
   FREE(keywordQueue)
   LOOP UNTIL ERRORCODE()
        szBuffer = CLIP(LEFT(A_A.Buffer))
        IF szBuffer <> '' AND szBuffer[1] <> '!'
           IF szBuffer[1] = '['
              BREAK
           ELSE
              !add to queue
              keywordQueue.keywords = szBuffer
              ADD(keywordQueue)
           END
        END
        NEXT(A_A)
   END
   !determine length needed for cstring
   bytesNeeded = 0
   j = RECORDS(keywordQueue)
   IF j > 0
      LOOP i = 1 TO j
         GET(keywordQueue,i)
         bytesNeeded += LEN(keywordQueue.keywords)
      END
      bytesNeeded += j+1

      !allocate cstring
      szKeywords &= NEW CSTRING(bytesNeeded)
      LOOP i = 1 TO j
         GET(keywordQueue,i)
         szKeywords = szKeywords & keywordQueue.keywords & ' '
      END
      szKeywords[LEN(szKeywords)] = '<0>'

      !assign to keyword list
      sciControl.SetKeyWords(setNumber,szKeywords)
      DISPOSE(szKeywords)
      szKeywords &= NULL
   END
   RETURN

DOO.ProcessStyles        PROCEDURE()
pDelimiter     LONG
pStart         LONG
firstStyle     BOOL(TRUE)

   CODE
   NEXT(A_A)
   LOOP UNTIL ERRORCODE()
        szBuffer = CLIP(LEFT(A_A.Buffer))
        IF szBuffer <> '' AND szBuffer[1] <> '!'
           IF szBuffer[1] = '['
              BREAK
           ELSE
              pDelimiter = INSTRING('=',szBuffer)
              IF pDelimiter
                 styleNumber = szBuffer[6 : pDelimiter-1]
                 LOOP WHILE pDelimiter < LEN(szBuffer)
                      pStart = pDelimiter+1
                      pDelimiter = INSTRING(',',szBuffer,,pStart)
                      IF pDelimiter
                         thisToken = szBuffer[pStart : pDelimiter-1]
                         DOO.ProcessToken()
                      ELSE
                         thisToken = szBuffer[pStart : LEN(szBuffer)]
                         DOO.ProcessToken()
                         BREAK
                      END
                 END
                 IF firstStyle
                    IF styleNumber = 32
                       SciControl.StyleClearAll()
                    END
                    firstStyle = FALSE
                 END
              ELSE
                 BREAK
              END
              !style0=font:Times New Roman,fontsize:11,fore:#000000
              !process the style
           END
        END
        NEXT(A_A)
   END
   RETURN

DOO.ProcessToken   PROCEDURE()
nSize    LONG
szFont   CSTRING(33)
lRed     LONG
lGreen   LONG
lBlue    LONG
lColor   LONG
caseOpt  LONG

   CODE
!font:,size:,bold,italic,underline,fore:,back:,eolfilled,case:,hide,hotSpot
   CASE UPPER(thisToken[1 : 4])
     OF 'FONT'
        szFont = thisToken[6 : LEN(thisToken)]
        sciControl.StyleSetFont(styleNumber,szFont)
     OF 'SIZE'
        nSize = thisToken[6 : LEN(thisToken)]
        sciControl.StyleSetSize(styleNumber,nSize)
     OF 'BOLD'
        sciControl.StyleSetBold(styleNumber,TRUE)
     OF 'ITAL'
        sciControl.StyleSetItalic(styleNumber,TRUE)
     OF 'FORE'
        lRed   = EVALUATE('0' & thisToken[7  :  8] & 'h')
        lGreen = EVALUATE('0' & thisToken[9  : 10] & 'h')
        lblue  = EVALUATE('0' & thisToken[11 : 12] & 'h')
        sciControl.StyleSetFore(styleNumber,colourRGB(lRed,lGreen,lBlue))
     OF 'BACK'
        lRed   = EVALUATE('0' & thisToken[7  :  8] & 'h')
        lGreen = EVALUATE('0' & thisToken[9  : 10] & 'h')
        lblue  = EVALUATE('0' & thisToken[11 : 12] & 'h')
        sciControl.StyleSetBack(styleNumber,colourRGB(lRed,lGreen,lBlue))
     OF 'EOLF'
        sciControl.StyleSetEOLFilled(styleNumber,TRUE)
     OF 'CASE'
        caseOpt = thisToken[6 : LEN(thisToken)]
        IF INRANGE(caseOpt,0,2)
           sciControl.StyleSetCase(styleNumber,caseOpt)
        END
     OF 'HIDE'
        sciControl.StyleSetVisible(styleNumber,FALSE)
     OF 'HOTS'
        !sciControl.StyleSetHotSpot(styleNumber,TRUE)
        sciControl.StyleSetHotSpot(styleNumber,glo:bHotSpotsEnabled)
   END
[END]
[END]
[ADDITION]
NAME ABC cwHHProc
[INSTANCE]
INSTANCE 1
OWNER 2
[PROMPTS]
%cwHHFileName DEFAULT  ('')
%cwHHContextURL DEFAULT  ('')
%cwHHAltTrapKey DEFAULT  ('')
[CALLS]
ColourRGB
